<?xml version="1.0" encoding="UTF-8"?>

<x:description xmlns:x="http://www.jenitennison.com/xslt/xspec"
               xmlns:xslt="http://www.w3.org/1999/XSL/Transform"
               xmlns:xslout="http://www.w3.org/1999/XSL/Transform"
               xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
               xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
               xmlns:marc="http://www.loc.gov/MARC21/slim"
               xmlns:bf="http://id.loc.gov/ontologies/bibframe/"
               xmlns:bflc="http://id.loc.gov/ontologies/bflc/"
               xmlns:madsrdf="http://www.loc.gov/mads/rdf/v1#"
               xmlns:bf2marc="http://www.loc.gov/bf2marc"
               xmlns:local="http://example.org/local"
               stylesheet="../src/compile.xsl" xslt-version="1.0">

  <x:scenario label="Basic regression">
    <x:context href="data/minimal.xml"/>
    <x:expect label="...should match expected">
      <xslt:stylesheet xmlns:date="http://exslt.org/dates-and-times"
                       xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                       xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
                       xmlns:marc="http://www.loc.gov/MARC21/slim"
                       xmlns:bf="http://id.loc.gov/ontologies/bibframe/"
                       xmlns:bflc="http://id.loc.gov/ontologies/bflc/"
                       xmlns:madsrdf="http://www.loc.gov/mads/rdf/v1#"
                       xmlns:xslt="http://www.w3.org/1999/XSL/Transform"
                       xmlns:local="http://example.org/local"
                       version="1.0"
                       extension-element-prefixes="date"
                       exclude-result-prefixes="rdf rdfs bf bflc madsrdf local">
        <xslt:output encoding="UTF-8" method="xml" indent="yes"/>
        <xslt:strip-space elements="*"/>
        <xslt:param name="pRecordId" select="'default'"/>
        <xslt:param name="pGenerationDatestamp">
          <xslt:if test="function-available('date:date-time')">
            <xslt:value-of select="date:date-time()"/>
          </xslt:if>
        </xslt:param>
        <xslt:variable name="vCurrentVersion">0.1.0-TEST</xslt:variable>
        <xslt:template match="/">
          <xslt:choose>
            <xslt:when test="rdf:RDF">
              <xslt:choose>
                <xslt:when test="count(rdf:RDF/bf:Instance) = 1">
                  <xslt:choose>
                    <xslt:when test="count(rdf:RDF/bf:Work) = 0" />
                    <xslt:when test="count(rdf:RDF/bf:Work) = 1">
                      <xslt:choose>
                        <xslt:when test="rdf:RDF/bf:Instance/bf:instanceOf[@rdf:resource=/rdf:RDF/bf:Work/@rdf:about]" />
                        <xslt:when test="rdf:RDF/bf:Work/bf:hasInstance[@rdf:resource=/rdf:RDF/bf:Instance/@rdf:about]" />
                        <xslt:otherwise>
                          <xslt:message terminate="yes">Invalid document: top-level Instance and Work are not linked</xslt:message>
                        </xslt:otherwise>
                      </xslt:choose>
                    </xslt:when>
                    <xslt:otherwise>
                      <xslt:message terminate="yes">Invalid document: document can only have 0 or 1 top-level Work element</xslt:message>
                    </xslt:otherwise>
                  </xslt:choose>
                </xslt:when>
                <xslt:otherwise>
                  <xslt:message terminate="yes">Invalid document: document must have exactly one top-level Instance element</xslt:message>
                </xslt:otherwise>
              </xslt:choose>
            </xslt:when>
            <xslt:otherwise>
              <xslt:message terminate="yes">Invalid document: no RDF root element</xslt:message>
            </xslt:otherwise>
          </xslt:choose>
          <xslt:apply-templates/>
        </xslt:template>
        <xslt:template match="rdf:RDF">
          <xslt:variable name="vAdminMetadata" select="bf:Instance/bf:adminMetadata/bf:AdminMetadata | bf:Work/bf:adminMetadata/bf:AdminMetadata[not(/rdf:RDF/bf:Instance/bf:adminMetadata/bf:AdminMetadata)]" />
          <xslt:variable name="vRecordId">
            <xslt:choose>
              <xslt:when test="$pRecordId = 'default'">
                <xslt:choose>
                  <xslt:when test="$vAdminMetadata/bf:identifiedBy/bf:Local[not(bf:source) or bf:source/@rdf:resource='http://id.loc.gov/vocabulary/organizations/dlc' or bf:source/bf:Source/@rdf:about='http://id.loc.gov/vocabulary/organizations/dlc' or bf:source/bf:Source/rdfs:label='DLC']/rdf:value">
                    <xslt:value-of select="$vAdminMetadata/bf:identifiedBy/bf:Local[not(bf:source) or bf:source/@rdf:resource='http://id.loc.gov/vocabulary/organizations/dlc' or bf:source/bf:Source/@rdf:about='http://id.loc.gov/vocabulary/organizations/dlc' or bf:source/bf:Source/rdfs:label='DLC']/rdf:value" />
                  </xslt:when>
                  <xslt:otherwise>
                    <xslt:value-of select="generate-id()" />
                  </xslt:otherwise>
                </xslt:choose>
              </xslt:when>
              <xslt:otherwise>
                <xslt:value-of select="$pRecordId" />
              </xslt:otherwise>
            </xslt:choose>
          </xslt:variable>
          <marc:record/>
        </xslt:template>
        <xslt:template match="text()"/>
        <xslt:template name="EDTF-Date1">
          <xslt:param name="pEDTFDate" />
          <xslt:choose>
            <xslt:when test="contains($pEDTFDate,'/')">
              <xslt:value-of select="substring-before($pEDTFDate,'/')" />
            </xslt:when>
            <xslt:otherwise>
              <xslt:value-of select="$pEDTFDate" />
            </xslt:otherwise>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="EDTF-Date2">
          <xslt:param name="pEDTFDate" />
          <xslt:value-of select="substring-after($pEDTFDate,'/')" />
        </xslt:template>
        <xslt:template name="EDTF-DatePart">
          <xslt:param name="pEDTFDate" />
          <xslt:choose>
            <xslt:when test="contains($pEDTFDate,'T')">
              <xslt:value-of select="substring-before($pEDTFDate,'T')" />
            </xslt:when>
            <xslt:otherwise>
              <xslt:value-of select="$pEDTFDate" />
            </xslt:otherwise>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="EDTF-TimePart">
          <xslt:param name="pEDTFDate" />
          <xslt:choose>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'+')">
              <xslt:value-of select="substring-before(substring-after($pEDTFDate,'T'),'+')" />
            </xslt:when>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'-')">
              <xslt:value-of select="substring-before(substring-after($pEDTFDate,'T'),'-')" />
            </xslt:when>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'Z')">
              <xslt:value-of select="substring-before(substring-after($pEDTFDate,'T'),'Z')" />
            </xslt:when>
            <xslt:otherwise>
              <xslt:value-of select="substring-after($pEDTFDate,'T')" />
            </xslt:otherwise>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="EDTF-TimeDiff">
          <xslt:param name="pEDTFDate" />
          <xslt:choose>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'+')">
              <xslt:value-of select="concat('+',substring-after(substring-after($pEDTFDate,'T'),'+'))" />
            </xslt:when>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'-')">
              <xslt:value-of select="concat('-',substring-after(substring-after($pEDTFDate,'T'),'-'))" />
            </xslt:when>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'Z')">+00:00</xslt:when>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="EDTF-to-033">
          <xslt:param name="pEDTFDate" />
          <xslt:variable name="vEDTFDate"
                         select="translate(translate(translate($pEDTFDate,'?',''),'~',''),'%','')" />
          <xslt:variable name="vDatePart">
            <xslt:call-template name="EDTF-DatePart">
              <xslt:with-param name="pEDTFDate"
                               select="$vEDTFDate" />
            </xslt:call-template>
          </xslt:variable>
          <xslt:variable name="vTimePart">
            <xslt:call-template name="EDTF-TimePart">
              <xslt:with-param name="pEDTFDate"
                               select="$vEDTFDate" />
            </xslt:call-template>
          </xslt:variable>
          <xslt:variable name="vTimeDiffPart">
            <xslt:call-template name="EDTF-TimeDiff">
              <xslt:with-param name="pEDTFDate"
                               select="$vEDTFDate" />
            </xslt:call-template>
          </xslt:variable>
          <xslt:variable name="vYear">
            <xslt:variable name="vYear033">
              <xslt:choose>
                <xslt:when test="contains($vDatePart,'-')">
                  <xslt:value-of select="translate(substring-before($vDatePart,'-'),'X','-')" />
                </xslt:when>
                <xslt:otherwise>
                  <xslt:value-of select="translate($vDatePart,'X','-')" />
                </xslt:otherwise>
              </xslt:choose>
            </xslt:variable>
            <xslt:choose>
              <xslt:when test="starts-with($vYear033,'Y') or starts-with($vYear033,'-') or (string-length($vYear033) != 4)">
                <xslt:text>----</xslt:text>
              </xslt:when>
              <xslt:otherwise>
                <xslt:value-of select="$vYear033" />
              </xslt:otherwise>
            </xslt:choose>
          </xslt:variable>
          <xslt:variable name="vMonth">
            <xslt:variable name="vMonth033">
              <xslt:choose>
                <xslt:when test="substring-after(substring-after($vDatePart,'-'),'-') != ''">
                  <xslt:value-of select="translate(substring-before(substring-after($vDatePart,'-'),'-'),'X','-')" />
                </xslt:when>
                <xslt:otherwise>
                  <xslt:value-of select="translate(substring-after($vDatePart,'-'),'X','-')" />
                </xslt:otherwise>
              </xslt:choose>
            </xslt:variable>
            <xslt:choose>
              <xslt:when test="(string-length($vMonth033) != 2) or ($vMonth033 > 12)">
                <xslt:text>--</xslt:text>
              </xslt:when>
              <xslt:otherwise>
                <xslt:value-of select="$vMonth033" />
              </xslt:otherwise>
            </xslt:choose>
          </xslt:variable>
          <xslt:variable name="vDay">
            <xslt:variable name="vDay033"
                           select="translate(substring-after(substring-after($vDatePart,'-'),'-'),'X','-')" />
            <xslt:choose>
              <xslt:when test="(string-length($vDay033) != 2) or ($vDay033 > 31)">
                <xslt:text>--</xslt:text>
              </xslt:when>
              <xslt:otherwise>
                <xslt:value-of select="$vDay033" />
              </xslt:otherwise>
            </xslt:choose>
          </xslt:variable>
          <xslt:variable name="vTime">
            <xslt:if test="$vTimePart != ''">
              <xslt:variable name="vTime033"
                             select="translate(translate($vTimePart,'X','-'),':','')" />
              <xslt:choose>
                <xslt:when test="string-length($vTime033) = 6">
                  <xslt:value-of select="$vTime033" />
                </xslt:when>
                <xslt:otherwise>------</xslt:otherwise>
              </xslt:choose>
            </xslt:if>
          </xslt:variable>
          <xslt:variable name="vTimeDiff">
            <xslt:if test="($vTimePart != '') and ($vTimeDiffPart != '')">
              <xslt:variable name="vTimeDiff033"
                             select="translate(translate($vTimeDiffPart,'X','-'),':','')" />
              <xslt:choose>
                <xslt:when test="string-length($vTimeDiff033) = 5">
                  <xslt:value-of select="$vTimeDiff033" />
                </xslt:when>
                <xslt:when test="string-length($vTimeDiff033) = 3">
                  <xslt:value-of select="concat($vTimeDiff033,'00')" />
                </xslt:when>
              </xslt:choose>
            </xslt:if>
          </xslt:variable>
          <xslt:value-of select="concat($vYear,$vMonth,$vDay,$vTime,$vTimeDiff)" />
        </xslt:template>
      </xslt:stylesheet>
    </x:expect>
  </x:scenario>

  <x:scenario label="Load rules from included files">
    <x:context href="data/file.xml"/>
    <x:expect label="...should create transforms for all included files"
              test="count(//marc:leader)=1 and count(//marc:controlfield)=3"/>
  </x:scenario>

  <x:scenario label="map element">
    <x:context mode="map">
      <bf2marc:map name="instruments">
        <instrument>
          <code>ba</code>
          <type>brass</type>
          <label>horn</label>
        </instrument>
        <instrument>
          <code>bb</code>
          <type>brass</type>
          <label>trumpet</label>
        </instrument>
      </bf2marc:map>
    </x:context>
    <x:expect label="...should generate a variable with the embedded XML data structure">
      <local:instruments>
        <instrument>
          <code>ba</code>
          <type>brass</type>
          <label>horn</label>
        </instrument>
        <instrument>
          <code>bb</code>
          <type>brass</type>
          <label>trumpet</label>
        </instrument>
      </local:instruments>
      <xslt:variable name="instruments" select="document('')/*/local:instruments"/>
    </x:expect>
  </x:scenario>

  <x:scenario label="Document frame">
    <x:scenario label="Rule without context element">
      <x:context mode="documentFrame">
        <bf2marc:cf tag="001"/>
      </x:context>
      <x:expect label="...should generate a frame for the target MARC element">
        <marc:controlfield>
          <xslt:attribute name="tag">001</xslt:attribute>
        </marc:controlfield>
      </x:expect>
    </x:scenario>

    <x:scenario label="Rule with context element">
      <x:context mode="documentFrame">
        <bf2marc:cf tag="001">
          <bf2marc:context xpath="bf:Instance"/>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...should generate an apply-templates element">
        <xslt:apply-templates select="bf:Instance" mode="generate-001">
          <xslt:with-param name="vRecordId" select="$vRecordId"/>
          <xslt:with-param name="vAdminMetadata" select="$vAdminMetadata"/>
        </xslt:apply-templates>
      </x:expect>
    </x:scenario>
  </x:scenario>

  <x:scenario label="Template generation">
    <x:scenario label="Rule with context element">
      <x:context mode="generateTemplates">
        <bf2marc:cf tag="001">
          <bf2marc:context xpath="bf:Instance"/>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...should generate a template for transforming the matched node into the specified MARC element"
                test="xslt:template/@match='bf:Instance' and xslt:template/@mode='generate-001'"/>
    </x:scenario>

    <x:scenario label="Non-repeatable field">
      <x:context mode="generateTemplates">
        <bf2marc:cf tag="001">
          <bf2marc:context xpath="bf:Instance"/>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...source element should only pass through template once"
                test="xslt:template/xslt:choose/xslt:when[1]/@test='position() = 1'"/>
    </x:scenario>
  </x:scenario>

  <x:scenario label="MARC field frame">
    <x:scenario label="cf element">
      <x:context mode="fieldTemplate">
        <bf2marc:cf tag="001"/>
      </x:context>
      <x:expect label="...should generate frame for target MARC control field">
        <marc:controlfield>
          <xslt:attribute name="tag">001</xslt:attribute>
        </marc:controlfield>
      </x:expect>
    </x:scenario>

    <x:scenario label="cf element with tag='LDR'">
      <x:context mode="fieldTemplate">
        <bf2marc:cf tag="LDR"/>
      </x:context>
      <x:expect label="...should generate frame for MARC leader">
        <marc:leader/>
      </x:expect>
    </x:scenario>

    <x:scenario label="bare value in cf">
      <x:context mode="fieldTemplate">
        <bf2marc:cf tag="001">12345678</bf2marc:cf>
      </x:context>
      <x:expect label="...should generate frame for target MARC control field with bare value"
                test="marc:controlfield/xslt:attribute[@name='tag']='001' and marc:controlfield/xslt:text='12345678'"/>
    </x:scenario>

    <x:scenario label="Processing rules in cf or df element">
      <x:context mode="fieldTemplate">
        <bf2marc:cf tag="001">
          <bf2marc:select xpath="bf:Instance">12345678</bf2marc:select>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...should generate XSL logic for processing document"
                test="count(marc:controlfield/xslt:for-each)=1"/>
    </x:scenario>

    <x:scenario label="df element">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245"/>
      </x:context>
      <x:expect label="...should generate frame for target MARC data field">
        <marc:datafield>
          <xslt:attribute name="tag">245</xslt:attribute>
        </marc:datafield>
      </x:expect>
    </x:scenario>

    <x:scenario label="ind1 or ind2 element">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245">
          <bf2marc:ind1>1</bf2marc:ind1>
          <bf2marc:ind2>0</bf2marc:ind2>
        </bf2marc:df>
      </x:context>
      <x:expect label="...should generate ind1/ind2 attributes of target MARC data field">
        <marc:datafield>
          <xslt:attribute name="tag">245</xslt:attribute>
          <xslt:attribute name="ind1"><xslt:text>1</xslt:text></xslt:attribute>
          <xslt:attribute name="ind2"><xslt:text>0</xslt:text></xslt:attribute>
        </marc:datafield>
      </x:expect>
    </x:scenario>

    <x:scenario label="default attribute for ind1 or ind2 element">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245">
          <bf2marc:ind1 default="1"/>
          <bf2marc:ind2 default="0">
            <bf2marc:select xpath="bf:code"/>
          </bf2marc:ind2>
        </bf2marc:df>
      </x:context>
      <x:expect label="...sets the default value for the ind1/ind2 attributes"
                test="marc:datafield/xslt:attribute[@name='ind1']/xslt:text='1' and
                      marc:datafield/xslt:attribute[@name='ind2']/xslt:choose/xslt:otherwise/xslt:text='0'"/>
    </x:scenario>

    <x:scenario label="sf element">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245">
          <bf2marc:sf code="a"/>
        </bf2marc:df>
      </x:context>
      <x:expect label="...should create frame for target MARC subfield"
                test="count(marc:datafield//marc:subfield[@code='a'])=1"/>
    </x:scenario>

    <x:scenario label="bare value in sf">
      <x:context mode="fieldTemplate">
        <bf2marc:sf code="a">test</bf2marc:sf>
      </x:context>
      <x:expect label="...should generate frame for target MARC subfield with bare value">
        <marc:subfield code="a">test</marc:subfield>
      </x:expect>
    </x:scenario>

    <x:scenario label="Processing rules in sf">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245">
          <bf2marc:sf code="a" repeatable="false">
            <bf2marc:switch>
              <bf2marc:case test="bf:mainTitle">title from bf:mainTitle</bf2marc:case>
              <bf2marc:case test="rdfs:label">title from rdfs:label</bf2marc:case>
            </bf2marc:switch>
          </bf2marc:sf>
        </bf2marc:df>
      </x:context>
      <x:expect label="...should create a variable to hold value"
                test="count(marc:datafield/xslt:variable[@name='v245-a'])=1"/>
      <x:expect label="...and use that variable to decide whether to generate the subfield"
                test="marc:datafield/xslt:if/@test='$v245-a != '''''"/>
    </x:scenario>
  </x:scenario>

  <x:scenario label="Rule building blocks">
    <x:scenario label="Simple select element">
      <x:context mode="fieldTemplate">
        <bf2marc:select xpath="rdfs:label"/>
      </x:context>
      <x:expect label="...should generate a for-each loop over the xpath">
        <xslt:for-each select="rdfs:label">
          <xslt:value-of select="."/>
        </xslt:for-each>
      </x:expect>
    </x:scenario>

    <x:scenario label="select within sf element">
      <x:context mode="fieldTemplate">
        <bf2marc:sf code="a">
          <bf2marc:select xpath="rdfs:label"/>
        </bf2marc:sf>
      </x:context>
      <x:expect label="...should generate the frame of the target MARC subfield">
        <xslt:for-each select="rdfs:label">
          <marc:subfield code="a"><xslt:value-of select="."/></marc:subfield>
        </xslt:for-each>
      </x:expect>
    </x:scenario>

    <x:scenario label="select within non-repeatable field or subfield">
      <x:context mode="generateTemplates">
        <bf2marc:cf tag="001">
          <bf2marc:context xpath="bf:Instance/bf:title/bf:Title">
            <bf2marc:select xpath="rdfs:label"/>
          </bf2marc:context>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...should only allow one pass through the loop"
                test="xslt:template//xslt:for-each/xslt:choose/xslt:when[1]/@test='position() = 1'"/>
    </x:scenario>

    <x:scenario label="select with bare value">
      <x:context mode="fieldTemplate">
        <bf2marc:select xpath="rdfs:label">test value</bf2marc:select>
      </x:context>
      <x:expect label="...should generate xsl:text node with value">
        <xslt:for-each select="rdfs:label">
          <xslt:text>test value</xslt:text>
        </xslt:for-each>
      </x:expect>
    </x:scenario>

    <x:scenario label="switch/case">
      <x:context mode="fieldTemplate">
        <bf2marc:switch>
          <bf2marc:case test="1=1"/>
          <bf2marc:case test="1=0"/>
          <bf2marc:case test="default"/>
        </bf2marc:switch>
      </x:context>
      <x:expect label="...should generate an xsl:choose nodeset">
        <xslt:choose>
          <xslt:when test="1=1"/>
          <xslt:when test="1=0"/>
          <xslt:otherwise/>
        </xslt:choose>
      </x:expect>
    </x:scenario>

    <x:scenario label="case with bare value">
      <x:context mode="fieldTemplate">
        <bf2marc:switch>
          <bf2marc:case test="1=1">test</bf2marc:case>
        </bf2marc:switch>
      </x:context>
      <x:expect label="...should generate xsl:text node with value">
        <xslt:choose>
          <xslt:when test="1=1"><xslt:text>test</xslt:text></xslt:when>
        </xslt:choose>
      </x:expect>
    </x:scenario>

    <x:scenario label="fixed-field/position">
      <x:context mode="fieldTemplate">
        <bf2marc:fixed-field>
          <bf2marc:position>test</bf2marc:position>
          <bf2marc:position><bf2marc:select xpath="rdfs:label"/></bf2marc:position>
        </bf2marc:fixed-field>
      </x:context>
      <x:expect label="...should generate XSL logic to generate concatenated values"
                test="count(/xslt:text) = 1 and count(//xslt:for-each) = 1"/>
      <x:expect label="...bare value should generate xsl:text node with value"
                test="/xslt:text = 'test'"/>
      <x:expect label="...select element should be non-repeatable"
                test="/xslt:variable/xslt:for-each/xslt:choose/xslt:when[1]/@test='position() = 1'"/>
    </x:scenario>

    <x:scenario label="lookup/lookupField">
      <x:context mode="fieldTemplate">
        <bf2marc:lookup map="test" targetField="code">
          <bf2marc:lookupField name="field1" xpath="rdfs:label"/>
          <bf2marc:lookupField name="field2">lookmeup</bf2marc:lookupField>
        </bf2marc:lookup>
      </x:context>
      <x:expect label="...lookupField with xpath attribute should generate variable"
                test="count(/xslt:variable[@name='vfield1']) = 1"/>
      <x:expect label="...with value from xpath"
                test="/xslt:variable[@name='vfield1']/xslt:value-of/@select = 'rdfs:label'"/>
      <x:expect label="...lookup creates XPath expression to pull value from map"
                test="count(/xslt:value-of/@select) = 1"/>
      <x:expect label="...lookupField with xpath uses variable in select"
                test="contains(/xslt:value-of/@select,'field1=$vfield1') = true()"/>
      <x:expect label="...lookupField with bare value uses string in select"
                test="contains(/xslt:value-of/@select,'lookmeup') = true()"/>
    </x:scenario>

    <x:scenario label="transform element">
      <x:context mode="fieldTemplate">
        <bf2marc:transform>
          <xslout:text>test</xslout:text>
        </bf2marc:transform>
      </x:context>
      <x:expect label="...XSL should be copied into output stylesheet">
        <xslt:text>test</xslt:text>
      </x:expect>
    </x:scenario>
  </x:scenario>

</x:description>
